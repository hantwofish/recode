排序 + 滑动窗口

时间：O(N*logN)，Java：31ms，99%

空间：O(logN)

遇到这种消耗次数调整数组的题，再结合题目给定的数据范围（要求至少要达到N*logN的时间复杂度），我的第一反应就是滑动窗口，之前刷了好多滑窗的题，碰到不少类似的了
像这种消耗次数调整数组，以达到某个条件，并求最长满足多长的问题，可以往滑窗上想。

995. K 连续位的最小翻转次数

713. 乘积小于K的子数组

1423. 可获得的最大点数

1208. 尽可能使字符串相等

1052. 爱生气的书店老板

395. 至少有 K 个重复字符的最长子串

。。。

思路：

枚举，在不超过k次调整的情况下，以每个位置（窗口右边界，下标1~n-1）做调整后的元素，其频数最大能有多大。

l,r：滑窗左右边界 

滑窗有效范围：[l...r) 窗口内的值，均认为（经过若干次的假定的调整后）等于nums[r-1]

rest：剩余可用的调整次数，初始为：k

spent：滑窗滑动过程中记录扩张时消耗的次数
窗口右边界 r 不断向右滑动，同时（在脑海中）将窗口内的值全部调整成[r-1]，直至没有剩余次数为止，或终止位置停。

    public static int maxFrequency(int[] nums, int k) {
        Arrays.sort(nums);

        int n = nums.length, l = 0, r = 1, rest = k, spent, ans = 1;
        while (r < n) { 
            while (r < n && (spent = (r-l) * (nums[r]-nums[r-1])) <= rest) {
                rest -= spent; 
                r++;
            }
            ans = Math.max(ans, r - l); // 此时[l...r)窗口内的值均为nums[r-1]，个数为：r-l
            rest += nums[r-1]-nums[l++]; // 窗口左边界开始向右缩，[l]出窗口，释放消耗的次数：nums[r-1]-nums[l] 次
        }

        return ans;
    }